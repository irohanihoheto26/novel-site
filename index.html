<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fragment Library</title>
    <link href="https://fonts.googleapis.com/css2?family=Antonio:wght@700&family=Dela+Gothic+One&family=Noto+Sans+JP:wght@300&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    
    <style>
        /* =========================================
           BASE STYLES
           ========================================= */
        :root { 
            --sidebar-width: 280px; 
            --main-color: #fcaf17; 
            --bg-color: #f9f9f9; 
            --text-color: #333;
            --border-color: #eee;
        }

        body { 
            font-family: "Yu Gothic", "YuGothic", "Helvetica Neue", Arial, sans-serif; 
            background: var(--bg-color); 
            color: var(--text-color); 
            margin: 0; 
            display: flex; 
            min-height: 100vh; 
            line-height: 1.6;
        }

        /* --- Sidebar --- */
        aside { 
            width: var(--sidebar-width); 
            height: 100vh; 
            border-right: 1px solid #ddd; 
            padding: 40px 20px; 
            box-sizing: border-box; 
            position: fixed; 
            left: 0; top: 0; 
            overflow-y: auto; 
            background: #fff; 
            display: flex; 
            flex-direction: column; 
            z-index: 100; 
        }

        main { 
            margin-left: var(--sidebar-width); 
            flex: 1; 
            padding: 40px; 
            max-width: 800px; 
            box-sizing: border-box; 
        }

        /* --- サイトタイトル (Fragment Original) --- */
        aside h1 { 
            font-family: 'Dela Gothic One', sans-serif !important; 
            font-size: 2.2em; 
            margin: 0 0 10px; 
            text-transform: uppercase; 
            cursor: pointer; 
            color: #000;
        }
        
        .site-subtitle {
            font-family: 'Dela Gothic One', sans-serif; 
            font-size: 1.8em; 
            letter-spacing: 0.2em; 
            color: #fcaf17; 
            margin-top: -25px; 
            margin-bottom: 30px; 
            white-space: nowrap; 
            display: inline-block; 
            transform: scaleX(0.6); 
            transform-origin: left center;
        }

        /* --- Buttons --- */
        button { 
            cursor: pointer; border: 1px solid #ccc; background: #fff; color: #333;
            padding: 10px 15px; border-radius: 4px; transition: 0.2s; 
            font-size: 0.95em; width: 100%; margin-bottom: 10px;
        }
        button:hover { background: #eee; }
        
        aside button, #auth-form button:first-of-type, button.btn-primary { 
            background: var(--main-color); color: #fff; border: 1px solid var(--main-color); font-weight: bold; 
        }
        aside button:hover, #auth-form button:first-of-type:hover {
            background: #e59d0f; opacity: 1;
        }
        .btn-outline { background: #fff; color: #333; border: 1px solid #ccc; }

        /* --- Inputs --- */
        input, textarea, select { 
            width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; 
            box-sizing: border-box; margin-bottom: 10px; font-family: inherit;
        }
        .search-box-side { background-image: none; padding: 10px; }

        /* --- List Design --- */
        #list { background: transparent; padding: 0; }
        .novel-row { 
            background: #fff; padding: 15px; border-bottom: 1px solid #eee; 
            display: flex; justify-content: space-between; align-items: flex-start; gap: 15px;
        }
        .novel-row:last-child { border-bottom: none; }
        
        /* タイトル文字色を黒に */
        .novel-title { 
            font-weight: bold; color: #000; cursor: pointer; font-size: 1.1em; text-decoration: none; 
        }
        .novel-title:hover { text-decoration: underline; }
        
        .tag-link { background: #f0f0f0; padding: 2px 6px; border-radius: 4px; color: #666; font-size: 0.8em; margin-right: 5px; cursor: pointer; text-decoration: none; display: inline-block; }
        .tag-link:hover { background: #e0e0e0; color: #333; }
        
        .novel-stats { font-size: 0.85em; color: #777; margin-top: 5px; }
        .count-badge { background: #eee; color: #555; font-size: 0.8em; padding: 2px 6px; border-radius: 4px; border: none; }

        /* --- Tabs --- */
        .tab-bar { border-bottom: 2px solid #eee; margin-bottom: 20px; gap: 15px; display: flex; }
        .tab-btn { 
            border: none; background: transparent; color: #888; padding: 10px 0; 
            border-bottom: 2px solid transparent; width: auto; margin: 0; border-radius: 0; font-weight: bold;
        }
        .tab-btn.active { color: #000; border-bottom: 2px solid #000; }

        /* --- Toggle Switch (Color Changing) --- */
        .switch { position: relative; display: inline-block; width: 44px; height: 24px; margin-right: 8px; vertical-align: middle; flex-shrink: 0; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        
        /* Default Active (Orange) */
        input:checked + .slider { background-color: var(--main-color); }
        input:checked + .slider:before { transform: translateX(20px); }
        
        /* R18 Active (Red) */
        #r18-check:checked + .slider { background-color: #ff4d4d; }

        .checkbox-group { display: flex; gap: 20px; margin-bottom: 20px; align-items: center; flex-wrap: wrap; }
        .checkbox-group label { display: flex; align-items: center; font-size: 0.9em; font-weight: bold; cursor: pointer; }

        /* --- Overlays --- */
        #editor-overlay, #reader-overlay, #author-page-overlay { 
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: #fff; z-index: 2000; overflow-y: auto; 
        }
        .overlay-content { max-width: 700px; margin: 40px auto; padding: 20px; }
        
        /* ★ 通知内のリンク用スタイル */
        .notification-link {
            cursor: pointer;
            text-decoration: underline;
            font-weight: bold;
        }
        .notification-link:hover {
            color: var(--main-color); /* マウスを乗せたらオレンジに */
        }

        /* --- Reader Sticky Nav (Mobile Floating Style) --- */
        .sticky-close { 
            /* PC Default: Top Sticky */
            position: sticky; top: 0; background: rgba(255,255,255,0.95); 
            padding: 10px 0; z-index: 2100; border-bottom: 1px solid #eee;
            display: flex; align-items: center; justify-content: center; gap: 15px;
        }
        
        /* --- 戻るボタンのスタイル（PC・スマホ共通） --- */
        .close-btn-style { 
            background: #e0e0e0; /* 背景を少し濃いグレーに */
            color: #333 !important; 
            padding: 4px 15px;   /* 大きさ */
            border-radius: 20px; /* 丸く */
            font-size: 0.85em; 
            font-weight: bold; 
            cursor: pointer; 
            border: none; 
            width: auto; 
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); /* 影 */
            
            /* PCでは左に隙間を空ける */
            margin-left: 40px; 
            height: fit-content; /* ★高さを中身に合わせる */
            align-self: center;  /* ★上下中央揃え */
            position: relative;
            top: 5px; /* 物理的に1px下げる */
        }
        .close-btn-style:hover { 
            background: #d0d0d0;
        }

        /* 名前変換フォーム（共通） */
        #name-changer-group {
            display: flex; align-items: center; gap: 5px;
        }
        #user-custom-name {
            margin: 0; padding: 5px 10px; font-size: 0.8em; border-radius: 20px; width: 120px; border: 1px solid #ccc;
        }
        #name-changer-group button {
            margin: 0; padding: 5px 15px; font-size: 0.8em; border-radius: 20px; width: auto; background: var(--main-color); color: #fff; border: none;
        }

        /* --- Mobile Responsive (< 800px) --- */
        @media screen and (max-width: 800px) {
            body { flex-direction: column; }
            aside { 
                width: 100%; height: auto; position: static; 
                border-right: none; border-bottom: 2px solid #000; padding: 15px; z-index: 10; 
            }
            main { margin-left: 0; padding: 15px; width: 100%; }
            #logged-in-nav { display: flex; gap: 10px; }
            #logged-in-nav button { margin-bottom: 0; }
            .novel-row { flex-direction: column; align-items: flex-start; gap: 5px; }

            /* スマホ用：下に浮くオーバーレイ */
            .sticky-close {
                position: fixed !important;
                top: auto !important; bottom: 30px !important; left: 50% !important;
                transform: translateX(-50%);
                width: 95% !important; max-width: 400px;
                height: 54px !important; /* ★高さを固定 */                
                background: rgba(255, 255, 255, 0.95) !important;
                backdrop-filter: blur(5px);
                padding: 0 10px !important;
                border-radius: 30px;
                border: 1px solid rgba(0,0,0,0.1);
                box-shadow: 0 4px 15px rgba(0,0,0,0.15);
                z-index: 9999 !important;
                transition: transform 0.3s ease-out, opacity 0.3s ease;
                
                /* 横並び・中央寄せ・間隔調整 */
                display: flex !important;
                flex-direction: row !important;
                flex-wrap: nowrap !important; /* 折り返し禁止 */
                align-items: center !important;
                justify-content: center !important;
                gap: 25px !important; /* ★間隔を狭める (40px -> 15px) */
                
            }
            
            .sticky-close.nav-hidden {
                transform: translateX(-50%) translateY(150%) !important;
                opacity: 0;
            }
            
            /* スマホ用ボタン調整（共通設定を引き継ぐのでこれだけでOK） */
            .close-btn-style { 
                /* PC用のマージンをリセット（gapで調整するため） */
                margin-left: 0 !important; 
            }
            
            #name-changer-group { height: 100%; align-items: center; }

            /* --- ★ リストの並び・大きさ・位置の再調整 --- */
            
            
        }

        /* Reader Specific */
        #read-body { font-family: "Yu Gothic Medium", "Yu Gothic", sans-serif; line-height: 2.2; margin-top: 40px; }
        .indent-text { text-indent: 1em; }
        .r18-badge { background: #ff4d4d; color: #fff; font-size: 0.7em; padding: 2px 8px; border-radius: 12px; margin-left: 5px; font-weight: bold; }
        .draft-badge { background: #e0f2ff; color: #004080; font-size: 0.75em; padding: 3px 10px; border-radius: 15px; margin-left: 5px; font-weight: bold; }

        /* Utility */
        .hidden { display: none !important; }
        .rule-link { color: #666; text-decoration: underline; cursor: pointer; font-size: 0.85em; margin-bottom: 5px; display: block;}
    </style>

    <style id="user-custom-style"></style>
    <style id="reader-custom-style"></style>
</head>

<body>

    <aside>
        <h1 onclick="location.reload()">Fragment</h1>
        <p class="site-subtitle">WEB小説投稿サイト</p>
        
        <div style="margin-bottom: 20px;">
            <span class="rule-link" onclick="openRules()">ルール（必読）</span>
            <span class="rule-link" onclick="openAboutPage()">このサイトについて</span>
        </div>
        
        <input type="text" style="display:none" aria-hidden="true">
        <input type="search" id="search-input" class="search-box-side" placeholder="検索..." oninput="getList()" autocomplete="off">
        
        <div id="logged-in-nav" class="hidden">
            <button onclick="openEditor()">新規投稿</button>
            <button class="btn-outline" onclick="doLogOut()">ログアウト</button>
        </div>
        <div id="guest-nav">
            <button onclick="toggleAuthForm()">ログイン / 登録</button>
        </div>
    </aside>

    <main>
        <section id="auth-form" class="hidden" style="border:2px solid #000; padding:20px; margin-bottom:40px;">
            <input type="email" id="email" placeholder="メールアドレス">
            <input type="password" id="password" placeholder="パスワード">
            <button onclick="doLogIn()">ログイン</button>
            <button onclick="doSignUp()" class="btn-outline">新規登録</button>
        </section>

        <div id="user-page" class="hidden">
            <div class="section-header">
                <h2 style="margin: 0;">執筆管理</h2>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <div style="display: flex; gap: 15px;">
                    <span class="settings-link" id="view-my-page-link" style="color: var(--main-color); cursor:pointer; text-decoration:underline; font-size:0.9em;">[マイページを確認]</span>
                    <span class="settings-link" onclick="toggleSettings()" style="cursor:pointer; text-decoration:underline; font-size:0.9em;">[設定]</span>
                </div>
                <button onclick="deleteAccount()" style="width: auto; background: none; border: none; color: #ff4d4d; text-decoration: underline; cursor: pointer; font-size: 0.8em; padding: 0; margin: 0;">アカウント削除</button>
            </div>
            <div id="my-profile-display" style="margin: 10px 0 20px 0;">
                <span id="display-current-name" style="font-weight: bold;">読み込み中...</span><span style="font-size: 0.9em; color: #888;"> さん</span>
            </div>
            <div id="profile-edit-area" class="profile-edit-area" style="background:#f9f9f9; padding:20px; border:1px solid #eee; margin-bottom:20px; display:none;">
                <input type="text" id="prof-name" placeholder="作者名">
                <textarea id="prof-bio" placeholder="自己紹介" rows="3"></textarea>
                <h3 style="font-size: 0.9em; margin: 15px 0 5px;">マイページデザイン (HTML/CSS)</h3>
                <button type="button" onclick="resetToTemplate()" style="width:auto; font-size:0.8em; margin-bottom:5px;">初期デザインに戻す</button>
                <textarea id="prof-css" style="width:100%; height:100px;"></textarea>
                <div style="margin-top: 20px; border-top: 1px dashed #ccc; padding-top: 20px;">
                    <h3 style="font-size: 0.9em; margin-bottom: 5px;">文章画面のカスタマイズ (CSS)</h3>
                    <button type="button" onclick="resetReaderDesign()" style="width:auto; font-size:0.8em; margin-bottom:5px;">初期デザインに戻す</button>
                    <textarea id="reader-custom-input" style="width:100%; height:100px;"></textarea>
                </div>
                <button onclick="saveProfile()" class="btn-primary" style="margin-top:15px;">更新</button>
            </div>
            <div id="notification-banner" class="hidden" style="background: #fff9f0; border: 1px solid #ffebcc; padding: 15px; margin-bottom: 20px; border-radius: 8px;">
                <div style="display:flex; justify-content:space-between; align-items:flex-start;">
                     <div style="flex:1;">
                         <div style="font-weight:bold; font-size:0.9em; color:#d48806; margin-bottom:5px;">お知らせ</div>
                         <div id="notification-list" style="font-size: 0.9em; color: #a67c33; line-height: 1.6;"></div>
                     </div>
                     <button onclick="clearNotifications()" style="width:auto; font-size:0.8em; padding:4px 12px; background:#fcaf17; color:#fff; border:none; border-radius:4px; margin-left:10px; cursor:pointer;">OK</button>
                </div>
            </div>
            <div id="user-stats-area" style="padding: 15px; background: #f0f0f0; border-radius: 8px; display: flex; gap: 20px; margin-bottom: 20px; font-size: 0.9em;">
                <span>合計いいね: <strong id="total-likes">0</strong></span>
                <span>フォロー: <strong id="following-count">-</strong></span>
                <span>フォロワー: <strong id="follower-count">-</strong></span>
            </div>
            <div id="my-works-list">読み込み中...</div>
        </div>
        
        <div id="library-section-header" style="margin-top: 80px; padding-top: 40px; border-top: 3px double #000; margin-bottom: 20px; display:flex; align-items:center; gap:15px;">
            <h2 style="margin: 0;">ライブラリ</h2>
            <div style="display: flex; align-items: center; gap: 10px; font-size:0.9em;">
                <select id="sort-order" onchange="getList()" style="width:auto; padding: 5px;">
                    <option value="created_at">最新順</option>
                    <option value="likes">いいね順</option>
                    <option value="char_count">文字数順</option>
                </select>
                <label style="cursor: pointer; display: flex; align-items: center;">
                    <input type="checkbox" id="exclude-r18" onchange="getList()" style="width:auto; margin-right:5px;"> R18を除く
                </label>
                <span id="search-result-count" style="font-size: 0.8em; color: #666;"></span>
            </div>
        </div>
        <div class="tab-bar">
            <button id="tab-all" class="tab-btn active" onclick="switchTab('all')">すべて</button>
            <button id="tab-follow" class="tab-btn" onclick="switchTab('follow')">フォロー中</button>
            <button id="tab-bookmark" class="tab-btn" onclick="switchTab('bookmark')">お気に入り</button>
        </div>
        <div id="list">読み込み中...</div>
    </main>

    <div id="series-overlay" class="hidden" style="position:fixed; top:0; left:0; width:100%; height:100%; background:#fff; z-index:2000; overflow-y:auto;">
        <style id="series-dynamic-style"></style>

        <div class="overlay-content">
            <button class="btn-outline" onclick="closeSeriesPage()" style="width:auto; margin:0;">← 戻る</button>
            
            <div id="series-view-area">
                <div style="margin-top:20px; border-bottom:1px solid #eee; padding-bottom:20px;">
                    <small style="color:#888;">シリーズ</small>
                    <h1 id="series-page-title" style="margin:5px 0;"></h1>
                    
                    <div id="series-custom-html-area"></div>

                    <div id="series-page-desc" style="color:#666; font-size:0.9em; margin-top:10px; white-space: pre-wrap;"></div>
                    <div id="series-author-area" style="margin-top:10px; font-size:0.9em;"></div>
                </div>
                <h3 style="margin-top:30px;">目次</h3>
                <div id="series-episode-list"></div>
            </div>
            <div id="series-edit-area" class="hidden" style="margin-top:20px; background:#f9f9f9; padding:20px; border-radius:8px;">
                    <h3>シリーズ情報の編集</h3>
                    <label style="font-weight:bold; font-size:0.9em;">基本情報</label>
                    <input type="text" id="edit-series-title" placeholder="シリーズタイトル">
                    <textarea id="edit-series-desc" placeholder="あらすじ（一覧ページなどに表示されます）" rows="3"></textarea>
                    
                    <h4 style="margin-top:20px; margin-bottom:10px;">デザインカスタマイズ (HTML/CSS)</h4>
                    
                    <div style="display:flex; justify-content:space-between; align-items:flex-end; margin-bottom:5px;">
                        <p style="font-size:0.8em; color:#666; margin:0; line-height:1.4;">
                            ここに書いたコードがシリーズページになります。<br>
                            ※ <code>&lt;div id="series-works-area"&gt;&lt;/div&gt;</code> の場所に小説リストが出ます。
                        </p>
                        <button onclick="resetSeriesTemplate()" style="width:auto; font-size:0.8em; padding:4px 10px; margin:0;">初期デザインに戻す</button>
                    </div>
            
                    <textarea id="edit-series-css" style="width:100%; height:200px; font-family:monospace;" placeholder="<style>...</style>..."></textarea>
                    
                    <div style="display:flex; justify-content:flex-end; gap:10px; margin-top:20px;">
                        <button class="btn-outline" onclick="toggleSeriesEditMode(false)" style="width:auto; margin:0;">キャンセル</button>
                        <button onclick="saveSeriesData()" style="width:auto; background:#fcaf17; color:#fff; border:none; font-weight:bold; margin:0;">保存する</button>
                    </div>
            
                    <div style="margin-top:15px; border-top:1px dashed #ccc; padding-top:15px; text-align:right;">
                         <button onclick="deleteSeries()" style="width:auto; background:none; border:none; color:red; text-decoration:underline; font-size:0.8em; padding:0;">このシリーズを削除</button>
                    </div>
            </div>
            </div>
    </div>
    <div id="reader-overlay">
        <div class="sticky-close">
            <div id="name-changer-group" class="hidden">
                <input type="text" id="user-custom-name" placeholder="あなたの名前">
                <button onclick="applyNameChange()">変換</button>
            </div>
            
            <button class="close-btn-style" onclick="closeReader()">← 戻る</button>
        </div>

        <div class="overlay-content">
            <h2 id="read-title" style="text-align:center; margin-bottom:5px;"></h2>            
            <div id="read-body" class="indent-text" style="white-space: pre-wrap; margin: 40px 0;"></div>
            <div id="series-nav" class="hidden" style="display:flex; justify-content:space-between; margin: 30px 0; padding: 20px 0; border-top: 1px dashed #ccc; border-bottom: 1px dashed #ccc;">
                <button id="prev-episode-btn" style="width:48%; margin:0;" onclick="">« 前の話</button>
                <button id="next-episode-btn" style="width:48%; margin:0;" onclick="">次の話 »</button>
            </div>
            <div id="reader-interactive-zone" style="border-top: 1px solid #000; padding-top: 20px; margin-top:50px; text-align:center;">
                <div style="margin-bottom:30px;">
                    <div style="display: flex; justify-content: center; gap: 15px; margin-bottom:15px;">
                        <button id="bookmark-btn" onclick="toggleBookmark()" style="width:auto; padding: 10px 20px;">
                            <span id="bookmark-icon">☆</span> <span id="bookmark-text"></span>
                        </button>
                        <button id="like-btn" onclick="toggleLike()" style="width:auto; padding: 10px 30px;">
                            ♥ <span id="read-like-text"></span> <span id="read-like-count">0</span>
                        </button>
                    </div>
                    <span id="author-link-zone" style="font-size:0.9em; color:#666;"></span>
                </div>
                
                <div style="text-align:left;">
                    <h3>コメント</h3>
                    <div id="comment-list"></div>
                    <div id="comment-form-area" class="hidden" style="margin-top: 20px;">
                        <textarea id="comment-input" placeholder="感想を書く..." rows="3"></textarea>
                        <div style="display: flex; align-items: center; gap:12px; margin-top:10px;">
                            <button onclick="postComment()" class="btn-outline" style="width:auto; margin:0;">コメントを送信</button>
                            <label style="font-size: 0.85em; color: #666; cursor: pointer;">
                                <input type="checkbox" id="comment-is-private" style="width:auto;"> 作者だけに公開
                            </label>
                        </div>
                    </div>
                    <div id="comment-guest-msg" class="hidden" style="margin-top: 20px; padding: 20px; background: #f9f9f9; text-align: center; color:#888;">
                        <p>コメントにはログインが必要です。</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="editor-overlay">
        <div class="overlay-content">
            <h2>新規投稿</h2>
            <input type="text" id="title-input" placeholder="タイトル">
            <div style="display:flex; gap:10px; margin-bottom:10px;">
                <select id="series-select" style="flex:1; margin-bottom:0; padding:10px; border:1px solid #ddd; border-radius:4px;">
                    <option value="">（シリーズなし）</option>
                </select>
                <button onclick="createNewSeries()" style="width:auto; margin:0; font-size:0.8em; padding:0 15px; white-space:nowrap;">＋ シリーズ作成</button>
            </div>
            <input type="text" id="tags-input" placeholder="タグ (カンマ区切り)">
            <textarea id="caption-input" placeholder="キャプション（あらすじ等）" rows="3"></textarea>
            
            <div class="checkbox-group">
                <label>
                    <span class="switch"><input type="checkbox" id="name-convert-check"><span class="slider"></span></span>
                    名前変換機能
                </label>
                <label>
                    <span class="switch"><input type="checkbox" id="private-check"><span class="slider"></span></span>
                    非公開(下書き)
                </label>
                <label>
                    <span class="switch"><input type="checkbox" id="r18-check"><span class="slider"></span></span>
                    R-18
                </label>
            </div>

            <div id="default-name-area" class="hidden" style="margin-bottom:20px;">
                <input type="text" id="default-name-input" placeholder="変換前の名前（例：花子）">
                <small style="color:#888; display:block; margin-top:5px;">※本文中のこの名前が、読者の指定した名前に変換されます。</small>
            </div>

            <textarea id="content-input" rows="20" placeholder="本文を入力..."></textarea>
            <div style="text-align:right; font-size:0.8em; color:#888; margin-bottom:5px;">
                文字数: <span id="current-count">0</span>
            </div>
            
            <button onclick="doPost()">公開／保存する</button>
            <button onclick="closeEditor()" class="btn-outline">閉じる</button>
        </div>
    </div>

    <div id="author-page-overlay" style="z-index:3000;">
        <div class="overlay-content">
            <button class="btn-outline" onclick="closeAuthorPage()" style="width:auto; margin:0;">← 戻る</button>
            <div id="author-profile-header" style="margin-top:20px;">
                <h1 id="author-page-name" style="font-family: 'Yu Gothic', sans-serif;"></h1>
                <div id="author-page-bio"></div>
            </div>
            <div id="author-page-works" style="margin-top:30px;"></div>
        </div>
    </div>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
    <script>
    // ==========================================
    // 1. CONFIGURATION & GLOBALS
    // ==========================================
    const u = 'https://fnobmngpstzolphexluc.supabase.co'.trim();
    const k = 'sb_publishable_wczOfUdvKuScZQJ0Lklx0w_D9XtJPqE'.trim();
    const api = window.supabase.createClient(u, k, {
        auth: {
            persistSession: true,
            autoRefreshToken: true,
            detectSessionInUrl: true
        }
    });

    let currentUser = null, userProfile = null, currentTab = 'all', currentReadingId = null;
    let editingNovelId = null, allMyNovels = [], originalContent = "";
    let currentReplyId = null; 
    let lastScrollTop = 0;
    
    // シリーズ編集用のID保存変数
    let currentOpenedSeriesId = null;

    // 初期デザインテンプレート (Reader)
    const defaultReaderTemplate = `<style>
    #reader-overlay { background-color: #ffffff; color: #333333; }
    #read-body { max-width: 700px; margin: 0 auto; font-size: 1.1em; line-height: 2; }
    </style>`;

    // 初期デザインテンプレート (Author Page)
    const defaultAuthorTemplate = `/* 【ベーステンプレート】 */
    <h1 class="default-title">サイトタイトル</h1>
    <div class="default-bio">ここに自己紹介を入力してください。</div>
    <div id="custom-works-area"></div>
    <style>
    #author-page-name { display: none; }
    .default-title { font-family: 'Yu Gothic', 'YuGothic', sans-serif; font-weight: bold; font-size: 1.8em; margin: 10px 0; color: #333; }
    .default-bio { font-size: 1em; color: #666; margin-bottom: 30px; line-height: 1.6; }
    .novel-row { padding: 15px 0; border-bottom: 1px solid #eee; }
    .novel-title { font-size: 1.1em; color: #333 !important; text-decoration: none; font-weight: bold; }
    .count-badge { font-size: 0.8em; color: #999; margin-left: 10px; }
    </style>`;

    // ★ シリーズ用 初期デザインテンプレート（ID埋め込み版）
    const defaultSeriesTemplate = `/* 【シリーズページ テンプレート】 */
    <div class="series-header">
        <div class="series-label">シリーズ</div>
        <h1 class="series-title">シリーズタイトル</h1>
        <div class="series-meta">
            作者: <span id="series-author-display" class="author-name">...</span>
        </div>
        <div class="series-desc">ここにシリーズのあらすじや説明を入力してください。<br>全○話完結予定です。</div>
    </div>
    
    <div class="toc-container">
        <h3 class="toc-heading">目次</h3>
        <div id="series-works-area"></div>
    </div>

    <style>
    /* 全体の枠組み */
    .series-header { border-bottom: 2px solid #fcaf17; padding-bottom: 20px; margin-bottom: 30px; }
    
    /* 「シリーズ」ラベル */
    .series-label { display: inline-block; background: #fcaf17; color: #fff; font-size: 0.8em; padding: 2px 8px; border-radius: 4px; margin-bottom: 5px; font-weight: bold; }

    /* タイトル */
    .series-title { font-size: 1.6em; margin: 5px 0 10px 0; color: #333; line-height: 1.4; }

    /* 情報エリア */
    .series-meta { font-size: 0.9em; color: #666; margin-bottom: 15px; }
    .author-name { color: #333; font-weight: bold; cursor: pointer; text-decoration: underline; }

    /* あらすじ */
    .series-desc { color: #444; font-size: 0.95em; line-height: 1.8; background: #f9f9f9; padding: 15px; border-radius: 8px; }

    /* 目次 */
    .toc-container { margin-top: 20px; }
    .toc-heading { font-size: 1.2em; border-left: 4px solid #ccc; padding-left: 10px; margin-bottom: 15px; color: #333; }

    /* リスト部分 */
    .novel-row { border-bottom: 1px dashed #eee; padding: 12px 5px; transition: background 0.2s; }
    .novel-row:hover { background: #fafafa; }
    </style>`;
<script>
    // ==========================================
    // 1. CONFIGURATION & GLOBALS
    // ==========================================
    const u = 'https://fnobmngpstzolphexluc.supabase.co'.trim();
    const k = 'sb_publishable_wczOfUdvKuScZQJ0Lklx0w_D9XtJPqE'.trim();
    const api = window.supabase.createClient(u, k, {
        auth: {
            persistSession: true,
            autoRefreshToken: true,
            detectSessionInUrl: true
        }
    });

    let currentUser = null, userProfile = null, currentTab = 'all', currentReadingId = null;
    let editingNovelId = null, allMyNovels = [], originalContent = "";
    let currentReplyId = null; 
    let lastScrollTop = 0;
    
    // ★ シリーズ編集用のID保存変数（ここを統一しました）
    let currentOpenedSeriesId = null;

    // 初期デザインテンプレート (Reader)
    const defaultReaderTemplate = `<style>
    #reader-overlay { background-color: #ffffff; color: #333333; }
    #read-body { max-width: 700px; margin: 0 auto; font-size: 1.1em; line-height: 2; }
    </style>`;

    // 初期デザインテンプレート (Author Page)
    const defaultAuthorTemplate = `/* 【ベーステンプレート】 */
    <h1 class="default-title">サイトタイトル</h1>
    <div class="default-bio">ここに自己紹介を入力してください。</div>
    <div id="custom-works-area"></div>
    <style>
    #author-page-name { display: none; }
    .default-title { font-family: 'Yu Gothic', 'YuGothic', sans-serif; font-weight: bold; font-size: 1.8em; margin: 10px 0; color: #333; }
    .default-bio { font-size: 1em; color: #666; margin-bottom: 30px; line-height: 1.6; }
    .novel-row { padding: 15px 0; border-bottom: 1px solid #eee; }
    .novel-title { font-size: 1.1em; color: #333 !important; text-decoration: none; font-weight: bold; }
    .count-badge { font-size: 0.8em; color: #999; margin-left: 10px; }
    </style>`;

    // ★ シリーズ用 初期デザインテンプレート（ID埋め込み・リッチ版）
    const defaultSeriesTemplate = `/* 【シリーズページ テンプレート】 */
    <div class="series-header">
        <div class="series-label">シリーズ</div>
        <h1 class="series-title">シリーズタイトル</h1>
        <div class="series-meta">
            作者: <span id="series-author-display" class="author-name">...</span>
        </div>
        <div class="series-desc">ここにシリーズのあらすじや説明を入力してください。<br>全○話完結予定です。</div>
    </div>
    
    <div class="toc-container">
        <h3 class="toc-heading">目次</h3>
        <div id="series-works-area"></div>
    </div>

    <style>
    .series-header { border-bottom: 2px solid #fcaf17; padding-bottom: 20px; margin-bottom: 30px; }
    .series-label { display: inline-block; background: #fcaf17; color: #fff; font-size: 0.8em; padding: 2px 8px; border-radius: 4px; margin-bottom: 5px; font-weight: bold; }
    .series-title { font-size: 1.6em; margin: 5px 0 10px 0; color: #333; line-height: 1.4; }
    .series-meta { font-size: 0.9em; color: #666; margin-bottom: 15px; }
    .author-name { color: #333; font-weight: bold; cursor: pointer; text-decoration: underline; }
    .series-desc { color: #444; font-size: 0.95em; line-height: 1.8; background: #f9f9f9; padding: 15px; border-radius: 8px; }
    .toc-container { margin-top: 20px; }
    .toc-heading { font-size: 1.2em; border-left: 4px solid #ccc; padding-left: 10px; margin-bottom: 15px; color: #333; }
    .novel-row { border-bottom: 1px dashed #eee; padding: 12px 5px; transition: background 0.2s; }
    .novel-row:hover { background: #fafafa; }
    </style>`;

    // ==========================================
    // 2. INITIALIZATION
    // ==========================================
    async function init() {
        const { data: { session } } = await api.auth.getSession();
        currentUser = session?.user || null;

        if (currentUser) {
            document.getElementById('logged-in-nav').classList.remove('hidden');
            document.getElementById('guest-nav').classList.add('hidden');
            document.getElementById('user-page').classList.remove('hidden');
            await loadProfile();
            await loadUserContent();
        }
        
        if (!userProfile || !userProfile.display_name || userProfile.display_name === "名無し") {
            if(currentUser) forceProfileSetup();
        }
        
        await getList();

        const contentInput = document.getElementById('content-input');
        if (contentInput) {
            contentInput.addEventListener('input', (e) => {
                const count = e.target.value.length;
                document.getElementById('current-count').innerText = count.toLocaleString();
            });
        }
    }

    // ==========================================
    // 3. AUTHENTICATION
    // ==========================================
    function toggleAuthForm() { document.getElementById('auth-form').classList.toggle('hidden'); }
    async function doLogIn() {
        const email = document.getElementById('email').value;
        const password = document.getElementById('password').value;
        const { data, error } = await api.auth.signInWithPassword({ email, password });
        if (error) alert("ログイン失敗: " + error.message);
        else setTimeout(() => { window.location.replace(window.location.pathname); }, 500);
    }    
    async function doSignUp() { 
        const { error } = await api.auth.signUp({ email: document.getElementById('email').value, password: document.getElementById('password').value }); 
        if(error) alert(error.message); else alert("メールを確認してください"); 
    }    
    async function doLogOut() {
        await api.auth.signOut();
        window.localStorage.clear(); window.sessionStorage.clear();
        window.location.replace(window.location.pathname);
    }
    async function deleteAccount() {
        if (!confirm("本当に退会しますか？")) return;
        const confirmName = prompt("退会を確認するため、あなたの作者名（または「退会」）を入力してください。");
        if (!confirmName) return;
        try {
            await api.from('novels').delete().eq('author_id', currentUser.id);
            await api.from('profiles').delete().eq('id', currentUser.id);
            alert("退会処理が完了しました。"); await doLogOut();
        } catch (err) { console.error(err); alert("エラーが発生しました。"); }
    }

    // ==========================================
    // 4. USER PROFILE & SETTINGS
    // ==========================================
    async function loadProfile() {
        const { data } = await api.from('profiles').select('*').eq('id', currentUser.id).maybeSingle();
        userProfile = data;
        if (data) {
            document.getElementById('prof-name').value = data.display_name || "名無し";
            document.getElementById('prof-bio').value = data.bio || "";
            document.getElementById('prof-css').value = data.custom_css || defaultAuthorTemplate;
            document.getElementById('reader-custom-input').value = data.reader_custom_code || defaultReaderTemplate;
            document.getElementById('display-current-name').innerText = data.display_name || "名無し";
            document.getElementById('view-my-page-link').onclick = () => openAuthorPage(currentUser.id);
        }
    }    
    async function saveProfile() {
        const name = document.getElementById('prof-name').value.trim();
        if (!name) return alert("作者名は必須です！");
        const updates = { id: currentUser.id, display_name: name, bio: document.getElementById('prof-bio').value, custom_css: document.getElementById('prof-css').value, reader_custom_code: document.getElementById('reader-custom-input').value, updated_at: new Date() };
        const { error } = await api.from('profiles').upsert(updates);
        if (error) alert("エラー: " + error.message); else { alert("設定を保存しました！"); location.reload(); }
    }
    function toggleSettings() { const s = document.getElementById('profile-edit-area'); s.style.display = s.style.display==='block'?'none':'block'; }
    function forceProfileSetup() { document.getElementById('profile-edit-area').style.display = 'block'; document.getElementById('prof-name').style.border = "2px solid red"; }
    function resetToTemplate() { if (confirm("初期化しますか？")) document.getElementById('prof-css').value = defaultAuthorTemplate; }
    function resetReaderDesign() { if (confirm("初期化しますか？")) document.getElementById('reader-custom-input').value = defaultReaderTemplate; }

    // ==========================================
    // 5. LIBRARY & LIST
    // ==========================================
    async function getList() {
        try {
            let { data: novels } = await api.from('novels').select('*').eq('is_private', false).order('created_at', { ascending: false });
            let baseNovels = novels || [];
            if (currentUser) baseNovels = baseNovels.filter(n => n.author_id !== currentUser.id);
            if (document.getElementById('exclude-r18').checked) baseNovels = baseNovels.filter(n => !n.is_r18);

            const sw = document.getElementById('search-input').value.toLowerCase();
            let filtered = baseNovels;
            if (currentTab === 'follow' && currentUser) {
                const { data: follows } = await api.from('follows').select('following_id').eq('follower_id', currentUser.id);
                const followingIds = (follows || []).map(f => f.following_id);
                filtered = filtered.filter(n => followingIds.includes(n.author_id));
            } else if (currentTab === 'bookmark' && currentUser) {
                const { data: myBms } = await api.from('bookmarks').select('novel_id').eq('user_id', currentUser.id);
                const bkmIds = (myBms || []).map(l => l.novel_id);
                filtered = filtered.filter(n => bkmIds.includes(n.id));
            }

            if (sw) filtered = filtered.filter(n => n.title.toLowerCase().includes(sw) || n.author_name.toLowerCase().includes(sw) || (n.tags && n.tags.some(t => t.toLowerCase().includes(sw))));
            document.getElementById('search-result-count').innerText = sw ? `${filtered.length} 件見つかりました` : "";
            
            // 統計取得
            const promises = filtered.map(async (n) => {
                const { data: p } = await api.from('profiles').select('display_name').eq('id', n.author_id).maybeSingle();
                if (p && p.display_name) {
                    n.author_name = p.display_name;
                }
                if (n.series_id) {
                    const { data: s } = await api.from('series').select('title').eq('id', n.series_id).single();
                    if (s) n.series_title = s.title;
                }
                const { count: lCount } = await api.from('likes').select('*', { count: 'exact', head: true }).eq('novel_id', n.id);
                const { count: cCount } = await api.from('comments').select('*', { count: 'exact', head: true }).eq('novel_id', n.id);
                n.like_count = lCount || 0; 
                n.comment_count = cCount || 0; 
                n.char_count = (n.content || "").length;
            });
            await Promise.all(promises);

            const sortType = document.getElementById('sort-order').value;
            if (sortType === 'likes') filtered.sort((a, b) => (b.like_count || 0) - (a.like_count || 0));
            else if (sortType === 'char_count') filtered.sort((a, b) => (b.char_count || 0) - (a.char_count || 0));

            renderFinalList(filtered);
        } catch (e) { console.error("getListエラー:", e); }
    }

    function renderFinalList(sortedNovels) {
        document.getElementById('list').innerHTML = sortedNovels.map(n => { 
            // シリーズ名のHTMLを作成
            const seriesLink = n.series_title 
                ? `<span onclick="openSeriesPage('${n.series_id}')" style="display:inline-block; background:#efefef; color:#555; font-size:0.75em; padding:2px 6px; border-radius:4px; cursor:pointer; margin-right:5px; vertical-align:middle;"><span class="material-icons" style="font-size:1.2em; vertical-align:text-bottom;">library_books</span> ${n.series_title}</span>` 
                : '';

            return `
            <div class="novel-row">
                <div class="novel-info">
                    <div style="margin-bottom:4px;">${seriesLink}</div>
                    <span class="novel-title" onclick="openReader('${n.id}')">${n.title}</span>
                    ${n.is_r18 ? '<span class="r18-badge">R18</span>' : ''}
                    <span onclick="openAuthorPage('${n.author_id}')" style="font-size:0.8em; color:#888; cursor:pointer; text-decoration:underline;"> / <span id="author-name-${n.id}">${n.author_name}</span></span>
                    <div style="margin-top:5px;">${(n.tags||[]).filter(t=>t.trim()).map(t=>`<span class="tag-link" onclick="setSearchTag('${t}')">#${t}</span>`).join('')}</div>
                </div>
                
                <div class="novel-stats" style="display:flex; align-items:center; gap:10px; flex-shrink:0; white-space:nowrap;">
                    <span class="count-badge">${(n.char_count || 0).toLocaleString()}文字</span>
                    
                    <span class="stat-item" style="display:flex; align-items:center;">
                        <span class="material-icons" style="font-size:1.1em; color:#ff4d4d; margin-right:2px;">favorite_border</span> 
                        ${n.like_count || 0}
                    </span>
                    
                    <span class="stat-item" style="display:flex; align-items:center;">
                        <span class="material-icons" style="font-size:1.1em; color:#888; margin-right:2px;">chat_bubble_outline</span> 
                        ${n.comment_count || 0}
                    </span>
                </div>
            </div>`;
        }).join('') || '<div style="padding:20px; text-align:center; color:#888;">作品がありません</div>'; 
    }
    function switchTab(t) { currentTab = t; document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', b.id === 'tab-'+t)); getList(); }
    function setSearchTag(tagName) { document.getElementById('search-input').value = tagName; getList(); document.getElementById('library-section-header').scrollIntoView({ behavior: 'smooth' }); }

    // ==========================================
    // 6. EDITOR
    // ==========================================
    async function loadUserContent() {
        if (!currentUser) return;

        const { count: following } = await api.from('follows').select('*', { count: 'exact', head: true }).eq('follower_id', currentUser.id);
        const { count: followers } = await api.from('follows').select('*', { count: 'exact', head: true }).eq('following_id', currentUser.id);
        
        const fEl = document.getElementById('following-count');
        const frEl = document.getElementById('follower-count');
        if (fEl) fEl.innerText = following || 0;
        if (frEl) frEl.innerText = followers || 0;

        let { data: novels } = await api.from('novels').select('*').eq('author_id', currentUser.id).order('created_at', {ascending: false});
        allMyNovels = novels || [];
        let totalLikesSum = 0;

        const promises = allMyNovels.map(async (n) => {
            if (n.series_id) {
                const { data: s } = await api.from('series').select('title').eq('id', n.series_id).single();
                if (s) n.series_title = s.title;
            }
            const { count: l } = await api.from('likes').select('*', { count: 'exact', head: true }).eq('novel_id', n.id);
            const { count: c } = await api.from('comments').select('*', { count: 'exact', head: true }).eq('novel_id', n.id);
            n.like_count = l || 0;
            n.comment_count = c || 0;
            totalLikesSum += n.like_count;
        });

        await Promise.all(promises);

        const totalLikesEl = document.getElementById('total-likes');
        if(totalLikesEl) totalLikesEl.innerText = totalLikesSum.toLocaleString();

        document.getElementById('my-works-list').innerHTML = allMyNovels.map(n => {
            const badge = n.is_private ? '<span class="draft-badge">下書き</span>' : (n.is_r18 ? '<span class="r18-badge">R18</span>' : '');
            
            // ★ Google Iconを使用
            const seriesLink = n.series_title 
                ? `<div style="width:100%; margin-bottom:4px;"><span onclick="openSeriesPage('${n.series_id}')" style="background:#efefef; color:#555; font-size:0.75em; padding:2px 6px; border-radius:4px; cursor:pointer;"><span class="material-icons" style="font-size:1.2em; vertical-align:text-bottom;">library_books</span> ${n.series_title}</span></div>` 
                : '';

            return `
            <div class="novel-row">
                <div class="novel-info">
                    ${seriesLink}
                    <span class="novel-title" onclick="openReader('${n.id}')">${n.title}</span> 
                    ${badge}
                    
                    <span class="novel-stats">
                        <span class="stat-item">
                            <span class="material-icons" style="font-size:1.1em; margin-right:2px; color:#ff4d4d; vertical-align:middle;">favorite_border</span> ${n.like_count}
                        </span>
                        <span class="stat-item">
                            <span class="material-icons" style="font-size:1.1em; margin-right:2px; color:#888; vertical-align:middle;">chat_bubble_outline</span> ${n.comment_count}
                        </span>
                    </span>
                </div>
                
                <div style="white-space: nowrap; margin-left: 10px;">
                    <span style="cursor:pointer; text-decoration:underline; font-size:0.8em; margin-right:10px;" onclick="openEditor('${n.id}')">[編集]</span>
                    <span style="cursor:pointer; text-decoration:underline; font-size:0.8em; color:red;" onclick="deleteNovel('${n.id}', '${n.title}')">[削除]</span>
                </div>
            </div>`;
        }).join('') || '<div style="padding:20px; color:#888;">作品はありません</div>';
    }
    
    async function openEditor(id = null) {
        editingNovelId = id;
        await loadSeriesOptions(); 
        
        if (id) {
            const n = allMyNovels.find(x => String(x.id) === String(id));
            if (!n) return;
            document.getElementById('title-input').value = n.title || "";
            document.getElementById('series-select').value = n.series_id || ""; 
            document.getElementById('tags-input').value = (n.tags || []).join(', ');
            document.getElementById('caption-input').value = n.caption || "";
            document.getElementById('content-input').value = n.content || "";
            document.getElementById('r18-check').checked = !!n.is_r18;
            document.getElementById('private-check').checked = !!n.is_private;
            document.getElementById('current-count').innerText = (n.content || "").length.toLocaleString();
            
            if (n.default_name) {
                document.getElementById('name-convert-check').checked = true;
                document.getElementById('default-name-area').classList.remove('hidden');
                document.getElementById('default-name-input').value = n.default_name;
            } else {
                document.getElementById('name-convert-check').checked = false;
                document.getElementById('default-name-area').classList.add('hidden');
                document.getElementById('default-name-input').value = "";
            }
        } else {
            document.getElementById('title-input').value = "";
            document.getElementById('series-select').value = ""; 
            document.getElementById('tags-input').value = "";
            document.getElementById('caption-input').value = "";
            document.getElementById('content-input').value = "";
            document.getElementById('r18-check').checked = false;
            document.getElementById('private-check').checked = false;
            document.getElementById('current-count').innerText = "0";
            document.getElementById('name-convert-check').checked = false;
            document.getElementById('default-name-area').classList.add('hidden');
        }
        document.getElementById('editor-overlay').style.display = 'block';
    }

    // シリーズ目次ページを開く
    async function openSeriesPage(seriesId) {
        const overlay = document.getElementById('series-overlay');
        overlay.classList.remove('hidden');
        
        // 編集エリアを閉じておく
        if (typeof toggleSeriesEditMode === 'function') toggleSeriesEditMode(false);

        const { data: s } = await api.from('series').select('*').eq('id', seriesId).single();
        if (!s) return alert("シリーズが見つかりません");

        // ★ ID保存（変数を統一）
        currentOpenedSeriesId = s.id;

        const { data: p } = await api.from('profiles').select('display_name').eq('id', s.author_id).maybeSingle();
        const authorName = p ? p.display_name : "名無し";

        const styleTag = document.getElementById('series-dynamic-style');
        const customArea = document.getElementById('series-custom-html-area');
        const fullCode = s.custom_css || "";
        const cssMatch = fullCode.match(/<style>([\s\S]*?)<\/style>/);
        if (styleTag) styleTag.innerHTML = cssMatch ? cssMatch[1] : ""; 
        if (customArea) customArea.innerHTML = fullCode.replace(/<style>[\s\S]*?<\/style>/g, ""); 
        
        // 編集フォーム初期値セット
        if (document.getElementById('edit-series-title')) document.getElementById('edit-series-title').value = s.title;
        if (document.getElementById('edit-series-desc')) document.getElementById('edit-series-desc').value = s.description || "";
        if (document.getElementById('edit-series-css')) document.getElementById('edit-series-css').value = s.custom_css || "";

        // ★ ボタン作成（ID埋め込み版に対応）
        const editBtn = (currentUser && currentUser.id === s.author_id) 
            ? `<button onclick="toggleSeriesEditMode(true)" style="font-size:0.7em; padding:2px 8px; margin-left:10px; vertical-align:middle; width:auto; display:inline-block;">編集</button>` 
            : '';

        document.getElementById('series-page-title').innerHTML = `${s.title} ${editBtn}`;
        document.getElementById('series-page-desc').innerText = s.description || "あらすじはありません";
        document.getElementById('series-author-area').innerHTML = `作者: <strong onclick="openAuthorPage('${s.author_id}')" style="cursor:pointer; text-decoration:underline;">${authorName}</strong>`;

        // ページが表示された後、HTML内の自動挿入タグに情報を流し込む
        setTimeout(() => {
             const authorDisp = document.getElementById('series-author-display');
             if(authorDisp) {
                 authorDisp.innerText = authorName;
                 authorDisp.onclick = () => openAuthorPage(s.author_id);
             }
        }, 100);

        // エピソード一覧
        let query = api.from('novels')
            .select('id, title, episode_number, is_r18, is_private, created_at, content')
            .eq('series_id', seriesId)
            .order('episode_number', { ascending: true });

        if (!currentUser || currentUser.id !== s.author_id) {
            query = query.eq('is_private', false);
        }

        const { data: episodes } = await query;

        // リスト描画（HTML内の series-works-area に入れる）
        const targetList = document.getElementById('series-works-area') || document.getElementById('series-episode-list');
        
        if (episodes && episodes.length > 0) {
            targetList.innerHTML = episodes.map(e => {
                const draftBadge = e.is_private ? '<span style="background:#e0f2ff; color:#004080; font-size:0.7em; padding:2px 6px; border-radius:4px; margin-left:5px;">下書き</span>' : '';
                const r18Badge = e.is_r18 ? '<span style="color:red; font-size:0.8em; margin-left:5px;">(R18)</span>' : '';

                return `
                <div class="novel-row" style="display:flex; justify-content:space-between; align-items:center;">
                    <div style="flex:1;">
                         <span style="font-weight:bold; color:#ccc; font-family:'Antonio', sans-serif; font-size:1.2em; width:30px; display:inline-block; text-align:right; margin-right:10px;">${e.episode_number}</span>
                         <span onclick="openReader('${e.id}')" style="cursor:pointer; font-weight:bold; font-size:1.05em; text-decoration:underline;">${e.title}</span>
                         ${draftBadge} ${r18Badge}
                    </div>
                    <span style="font-size:0.8em; color:#999; display:flex; align-items:center; flex-shrink:0;">
                       <span class="material-icons" style="font-size:1.1em; margin-right:2px;">description</span>
                       ${(e.content||"").length.toLocaleString()}
                    </span>
                </div>`;
            }).join('');
        } else {
            targetList.innerHTML = '<div style="padding:20px; color:#888;">エピソードがありません</div>';
        }
    }

    // シリーズ編集モード切替
    async function toggleSeriesEditMode(isEdit) {
        const viewArea = document.getElementById('series-view-area');
        const editArea = document.getElementById('series-edit-area');
        
        if (isEdit) {
            viewArea.classList.add('hidden');
            editArea.classList.remove('hidden');

            if (!currentOpenedSeriesId) return;
            
            const { data: s } = await api.from('series').select('*').eq('id', currentOpenedSeriesId).single();
            if (s) {
                document.getElementById('edit-series-title').value = s.title || "";
                document.getElementById('edit-series-desc').value = s.description || "";
                document.getElementById('edit-series-css').value = s.custom_css || defaultSeriesTemplate;
            }

        } else {
            viewArea.classList.remove('hidden');
            editArea.classList.add('hidden');
        }
    }

    // シリーズ保存
    async function saveSeriesData() {
        if (!currentOpenedSeriesId) return;
        
        const updates = {
            title: document.getElementById('edit-series-title').value,
            description: document.getElementById('edit-series-desc').value,
            custom_css: document.getElementById('edit-series-css').value
        };

        const { error } = await api.from('series').update(updates).eq('id', currentOpenedSeriesId);
        
        if(error) alert("保存エラー: " + error.message);
        else {
            alert("保存しました！");
            openSeriesPage(currentOpenedSeriesId);
        }
    }

    function resetSeriesTemplate() {
        if (confirm("デザインを初期テンプレートに戻しますか？\n現在の編集内容は失われます。")) {
            document.getElementById('edit-series-css').value = defaultSeriesTemplate;
        }
    }

    async function deleteSeries() {
        if (!confirm("本当にこのシリーズを削除しますか？\n（中の作品は削除されず、未分類に戻ります）")) return;

        await api.from('novels').update({ series_id: null }).eq('series_id', currentOpenedSeriesId);
        const { error } = await api.from('series').delete().eq('id', currentOpenedSeriesId);
        
        if (error) alert(error.message);
        else {
            alert("シリーズを削除しました。");
            closeSeriesPage();
            loadUserContent();
        }
    }
    
    function closeSeriesPage() {
        document.getElementById('series-overlay').classList.add('hidden');
        document.getElementById('series-dynamic-style').innerHTML = ""; 
        document.getElementById('series-custom-html-area').innerHTML = "";
    }

    async function doPost() {
        if (!userProfile || !userProfile.display_name || userProfile.display_name === "名無し") {
            alert("投稿するにはプロフィール設定で「作者名」を登録してください。");
            forceProfileSetup(); 
            return; 
        }

        const isNameConvert = document.getElementById('name-convert-check').checked;
        const defaultName = isNameConvert ? document.getElementById('default-name-input').value.trim() : "";

        const seriesId = document.getElementById('series-select').value || null;
        let updateOrder = null; 

        if (seriesId) {
            if (!editingNovelId) {
                const { count } = await api.from('novels').select('*', { count: 'exact', head: true }).eq('series_id', seriesId);
                updateOrder = (count || 0) + 1;
            } 
            else {
                const { data: current } = await api.from('novels').select('series_id').eq('id', editingNovelId).single();
                if (current.series_id !== seriesId) {
                    const { count } = await api.from('novels').select('*', { count: 'exact', head: true }).eq('series_id', seriesId);
                    updateOrder = (count || 0) + 1;
                }
            }
        }
        
        const payload = {
            title: document.getElementById('title-input').value,
            content: document.getElementById('content-input').value,
            caption: document.getElementById('caption-input').value,
            tags: document.getElementById('tags-input').value.split(',').map(t => t.trim()).filter(t => t),
            is_r18: document.getElementById('r18-check').checked,
            is_private: document.getElementById('private-check').checked,
            default_name: defaultName,
            author_id: currentUser.id,
            author_name: userProfile?.display_name || "名無し",
            series_id: seriesId
        };

        if (updateOrder !== null) {
            payload.episode_number = updateOrder;
        }
        if (!seriesId) {
            payload.episode_number = 0;
        }

        const { error } = editingNovelId 
            ? await api.from('novels').update(payload).eq('id', editingNovelId) 
            : await api.from('novels').insert(payload);
            
        if(error) {
            alert(error.message); 
        } else {
            location.reload();
        }
    }

    async function deleteNovel(id, title) {
        if (!confirm(`作品「${title}」を削除しますか？`)) return;
        await api.from('novels').delete().eq('id', id);
        location.reload();
    }

    function closeEditor() { document.getElementById('editor-overlay').style.display = 'none'; }

    async function loadSeriesOptions() {
        if (!currentUser) return;
        const { data } = await api.from('series').select('*').eq('author_id', currentUser.id).order('created_at', { ascending: false });
        const select = document.getElementById('series-select');
        select.innerHTML = '<option value="">（シリーズなし - 短編）</option>';
        if (data) {
            data.forEach(s => {
                const opt = document.createElement('option');
                opt.value = s.id;
                opt.innerText = s.title;
                select.appendChild(opt);
            });
        }
    }

    async function createNewSeries() {
        const title = prompt("新しいシリーズのタイトルを入力してください");
        if (!title) return;
        const { error } = await api.from('series').insert({ author_id: currentUser.id, title: title });
        if (error) alert("作成失敗: " + error.message);
        else {
            alert("シリーズを作成しました！");
            loadSeriesOptions();
        }
    }
    
    function goNeighborEpisode(direction) {
        // 将来の実装用
    }

    // ==========================================
    // 7. READER FUNCTIONS
    // ==========================================
    async function openReader(id) {
        currentReadingId = id;
        const bodyEl = document.getElementById('read-body');
        const titleEl = document.getElementById('read-title');
        const nameGroup = document.getElementById('name-changer-group');

        titleEl.style.textDecoration = "none";
        resetReaderUI();
        
        const { data: n, error } = await api.from('novels').select('*').eq('id', id).single();
        if(error || !n) return alert("作品が見つかりません");

        currentOpenedNovel = n;
        const { data: prof } = await api.from('profiles').select('display_name, reader_custom_code').eq('id', n.author_id).maybeSingle();
        const latestName = prof?.display_name || n.author_name;

        originalContent = n.content;
        titleEl.innerText = n.title;
        const readAuthorEl = document.getElementById('read-author');
        if (readAuthorEl) readAuthorEl.innerText = latestName;
        
        // 前後話ナビゲーション
        const seriesNav = document.getElementById('series-nav');
        if (n.series_id) {
            seriesNav.classList.remove('hidden');
            const { data: prev } = await api.from('novels').select('id, title').eq('series_id', n.series_id).lt('episode_number', n.episode_number).order('episode_number', { ascending: false }).limit(1).maybeSingle();
            const { data: next } = await api.from('novels').select('id, title').eq('series_id', n.series_id).gt('episode_number', n.episode_number).order('episode_number', { ascending: true }).limit(1).maybeSingle();

            const prevBtn = document.getElementById('prev-episode-btn');
            const nextBtn = document.getElementById('next-episode-btn');

            if (prev) { prevBtn.style.visibility = "visible"; prevBtn.innerText = "« " + prev.title; prevBtn.onclick = () => openReader(prev.id); } 
            else { prevBtn.style.visibility = "hidden"; }

            if (next) { nextBtn.style.visibility = "visible"; nextBtn.innerText = next.title + " »"; nextBtn.onclick = () => openReader(next.id); } 
            else { nextBtn.style.visibility = "hidden"; }
        } else {
            seriesNav.classList.add('hidden');
        }

        if (nameGroup) {
            if (n.default_name && n.default_name.trim() !== "") {
                nameGroup.classList.remove('hidden');
                const savedName = localStorage.getItem('user-default-name');
                if (savedName) document.getElementById('user-custom-name').value = savedName;
            } else {
                nameGroup.classList.add('hidden');
            }
        }
        bodyEl.innerText = n.content; 

        document.getElementById('author-link-zone').innerHTML = `
            作者: <strong onclick="openAuthorPage('${n.author_id}')" style="cursor:pointer; text-decoration:underline;">${latestName}</strong>
            ${(currentUser && n.author_id !== currentUser.id) ? `<button id="follow-btn" onclick="toggleFollow('${n.author_id}')" style="width:auto; padding:4px 12px; margin-left:10px; font-size:0.8em; border: 2px solid #fcaf17; background: #fff; color: #fcaf17; font-weight: bold; border-radius: 4px; cursor: pointer;">フォロー</button>` : ''}
        `;

        if (currentUser && n.author_id !== currentUser.id) checkFollowStatus(n.author_id);

        document.getElementById('reader-overlay').style.display = 'block';
        document.getElementById('reader-interactive-zone').classList.remove('hidden');

        const oldStyle = document.getElementById('dynamic-reader-style');
        if (oldStyle) oldStyle.remove();

        const styleTag = document.createElement('style'); 
        styleTag.id = 'dynamic-reader-style';
        let customCode = (prof && prof.reader_custom_code) ? prof.reader_custom_code : defaultReaderTemplate;
        
        const resetHelper = `
            #reader-overlay, .overlay-content { background-color: transparent; }
            #reader-overlay .close-btn-style { /* background: #c0c0c0; color: #444; */ }
        `;
        styleTag.textContent = resetHelper + customCode.replace(/<style>|<\/style>/g, '');
        document.head.appendChild(styleTag);

        loadComments(id);
        loadLikeCount(id);
        checkBookmarkStatus(id);

        const form = document.getElementById('comment-form-area');
        const msg = document.getElementById('comment-guest-msg');
        if (currentUser) { form.classList.remove('hidden'); msg.classList.add('hidden'); } 
        else { form.classList.add('hidden'); msg.classList.remove('hidden'); }
    }

    function closeReader() { 
        document.getElementById('reader-overlay').style.display = 'none'; 
        const oldStyle = document.getElementById('dynamic-reader-style');
        if (oldStyle) oldStyle.remove();
    }

    function applyNameChange() {
        const replacement = document.getElementById('user-custom-name').value;
        const target = currentOpenedNovel ? currentOpenedNovel.default_name : "";
        if (!target || !replacement) return alert("名前を入力してください");

        const regex = new RegExp(target.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
        const bodyElem = document.getElementById('read-body');
        if (bodyElem && typeof originalContent !== 'undefined') {
            bodyElem.textContent = originalContent.replace(regex, replacement);
            localStorage.setItem('user-default-name', replacement);
        }
    }

    function resetReaderUI() {
        const bodyEl = document.getElementById('read-body');
        const interactiveZone = document.getElementById('reader-interactive-zone');
        const nameChanger = document.getElementById('name-changer-group');
        const oldStyle = document.getElementById('dynamic-reader-style');
        if (oldStyle) oldStyle.remove();
        if (interactiveZone) interactiveZone.classList.add('hidden');
        if (nameChanger) nameChanger.classList.add('hidden');
        bodyEl.classList.remove('indent-text', 'hanging-indent');
        const titleEl = document.getElementById('read-title');
        if (titleEl) { titleEl.style.textDecoration = "none"; titleEl.style.color = ""; }
    }

    function openRules() {
        resetReaderUI(); 
        const bodyEl = document.getElementById('read-body');
        const titleEl = document.getElementById('read-title');
        const authorEl = document.getElementById('read-author');
        if (!titleEl || !bodyEl) return;

        titleEl.innerText = "ルール（必読）";
        titleEl.style.textDecoration = "underline";
        titleEl.style.textUnderlineOffset = "10px";
        if (authorEl) authorEl.innerText = "運営";

        bodyEl.innerHTML = `
        <div class="rules-container" style="margin-top: -80px; line-height: 1.4; font-size: 0.95em;">
            <p style="margin: -40px 0 -10px 0;">当サイトは個人による二次創作小説の展示・アーカイブを目的とした専用サイトです。</p>
            <div class="rules-list-box" style="margin: -20px 0 -20px 0; padding-left: 1.2em;">
                <div style="text-indent: -1.2em; margin-bottom: -20px;">・検索避けのため、<span style="color: #ff4d4d; font-weight: bold;">原作名をそのまま表示することは避けて</span>ください。</div>
                <div style="text-indent: -1.2em; margin-bottom: -20px;">・<span style="border-bottom: 1px solid #000; font-weight: bold;">公序良俗に反する内容の投稿、無断転載、AI学習利用は固く禁止</span>いたします。</div>
                <div style="text-indent: -1.2em; margin-bottom: -20px;">・<span style="background-color: #ffff00; padding: 0 2px;">R指定が必要な場合は必ず設定</span>を行ってください。</div>
            </div>
            <p style="margin: 10px 0 0 0;">ルールを守って、創作活動を楽しみましょう。</p>
        </div>`;
        document.getElementById('reader-overlay').style.display = 'block';
        document.getElementById('reader-overlay').scrollTop = 0;
    }

    function openAboutPage() {
        resetReaderUI();
        const titleEl = document.getElementById('read-title'); 
        const bodyEl = document.getElementById('read-body');    
        if (!titleEl || !bodyEl) return;

        titleEl.innerText = "このサイトについて";
        bodyEl.innerHTML = `
        <div class="about-section" style="margin-top: -110px;"> 
        <h3 style="color: #fcaf17; font-size: 1.05em; border-left: 4px solid #fcaf17; padding-left: 10px; margin: -50px 0 -15px 0;">サイトの特色</h3>
        <p style="font-size: 0.95em; margin: -20px 0 -10px 0; line-height: 1.2;">　当サイトは、かつて隆盛を誇った「個人サイト」のような自由な空気感を大切にしています。他の投稿サイトでは難しい細かなデザインカスタマイズが可能で、あなたの作品をあなたらしい空間で公開できるのが最大の特徴です。</p>
        <h3 style="color: #fcaf17; font-size: 1.05em; border-left: 4px solid #fcaf17; padding-left: 10px; margin: 0 0 -15px 0;">創設経緯</h3>
        <p style="font-size: 0.95em; margin: -20px 0 -10px 0; line-height: 1.2;">　SNSや大手プラットフォームの普及により、自分だけの「城」である個人サイトは激減しました。しかし、流れていくタイムラインではなく、自分の作品を自分の好きな色で飾り、静かに置いておける場所が今こそ必要だと感じています。</p>
        <h3 style="color: #fcaf17; font-size: 1.05em; border-left: 4px solid #fcaf17; padding-left: 10px; margin: 0 0 -15px 0;">機能について</h3>
        <p style="font-size: 0.95em; margin: -20px 0 -10px 0; line-height: 1.2;">◎いいね：作者に、誰が何にいいねしたか知らされます。いいねの数は公開されますが、誰が何にいいねしているかは非公開です。</p>
        <p style="font-size: 0.95em; margin: -20px 0 -10px 0; line-height: 1.2;">◎お気に入り：作者に、誰が何をお気に入りしたか知らされます。お気に入りの数も、誰が何をお気に入りしたかも非公開です。</p>
        <p style="font-size: 0.95em; margin: -20px 0 -10px 0; line-height: 1.2;">◎コメント：公開・非公開を選んで作者に送ることができます。コメントへの返信も同様です。</p>
        </div>`;
        document.getElementById('reader-overlay').style.display = 'block';
        document.getElementById('reader-overlay').scrollTop = 0;
    }

    // ==========================================
    // 8. INTERACTION
    // ==========================================
    async function toggleLike() {
        if(!currentUser) return alert("ログインが必要です");
        const safeId = String(currentReadingId); 

        const { data: existingLike, error: checkError } = await api.from('likes').select('*').eq('novel_id', safeId).eq('user_id', currentUser.id).maybeSingle();
        if (checkError) return;
        
        if (existingLike) {
            await api.from('likes').delete().eq('id', existingLike.id);
        } else {
            const { error: insertError } = await api.from('likes').insert({ novel_id: safeId, user_id: currentUser.id });
            if (insertError) { return alert("いいね失敗"); }
            
            if (currentOpenedNovel && currentOpenedNovel.author_id !== currentUser.id) {
                await api.from('notifications').insert({ 
                    target_user_id: currentOpenedNovel.author_id, 
                    from_user_name: userProfile?.display_name || "名無しさん", 
                    type: 'like', 
                    novel_title: currentOpenedNovel.title, 
                    novel_id: safeId 
                });
            }
        }
        loadLikeCount(safeId);
    }
    
    async function loadLikeCount(id) {
        const countEl = document.getElementById('read-like-count');
        const likeBtn = document.getElementById('like-btn');
        if (!countEl || !likeBtn) return;
        const { count } = await api.from('likes').select('*', { count: 'exact', head: true }).eq('novel_id', id);
        countEl.innerText = count || 0;
        if (currentUser) {
            const { data } = await api.from('likes').select('*').eq('novel_id', id).eq('user_id', currentUser.id).maybeSingle();
            if (data) { likeBtn.style.background = "#ff4d4d"; likeBtn.style.color = "#fff"; document.getElementById('read-like-text').innerText = ""; } 
            else { likeBtn.style.background = "#fff"; likeBtn.style.color = "#000"; document.getElementById('read-like-text').innerText = ""; }
        }
    }
    async function checkBookmarkStatus(novelId) {
        if (!currentUser) return;
        const { data } = await api.from('bookmarks').select('id').eq('user_id', currentUser.id).eq('novel_id', novelId).maybeSingle();
        const icon = document.getElementById('bookmark-icon');
        const btn = document.getElementById('bookmark-btn');
        if (data) { icon.innerText = "★"; btn.style.color = "#fcaf17"; btn.style.borderColor = "#fcaf17"; }
        else { icon.innerText = "☆"; btn.style.color = "#ccc"; btn.style.borderColor = "#ccc"; }
    }
    async function toggleBookmark() {
        if (!currentUser) return alert("ログインが必要です。");
        const safeId = String(currentReadingId); 

        const { data } = await api.from('bookmarks').select('id').eq('user_id', currentUser.id).eq('novel_id', safeId).maybeSingle();
        
        if (data) {
             await api.from('bookmarks').delete().eq('id', data.id);
        } else {
            const { error } = await api.from('bookmarks').insert({ user_id: currentUser.id, novel_id: safeId });
            
            if (!error && currentOpenedNovel && currentOpenedNovel.author_id !== currentUser.id) {
                await api.from('notifications').insert({
                    target_user_id: currentOpenedNovel.author_id,
                    from_user_name: userProfile?.display_name || "名無しさん",
                    type: 'bookmark',
                    novel_title: currentOpenedNovel.title,
                    novel_id: safeId 
                });
            }
        }
        checkBookmarkStatus(safeId);
    }
    
    async function loadComments(id) {
        const { data: comments, error } = await api.from('comments').select('*').eq('novel_id', id).order('created_at', {ascending: true});
        if (error) { document.getElementById('comment-list').innerHTML = "エラーが発生しました"; return; }
        const listEl = document.getElementById('comment-list');
        if (!comments || comments.length === 0) { listEl.innerHTML = "コメントはありません"; return; }
        const userIds = [...new Set(comments.map(c => c.user_id))];
        const { data: profiles } = await api.from('profiles').select('id, display_name').in('id', userIds);
        const nameMap = {}; profiles?.forEach(p => { nameMap[p.id] = p.display_name; });
        const parents = comments.filter(c => !c.parent_id);
        const replies = comments.filter(c => c.parent_id);
        listEl.innerHTML = parents.map(p => {
            const renderComment = (c, isReply) => {
                const isMine = currentUser && c.user_id === currentUser.id;
                const name = nameMap[c.user_id] || c.user_name || "名無し";
                const privateMark = c.is_private ? '<span style="background:#e0e0e0; color:#000; font-size:0.75em; padding:2px 6px; border-radius:4px; margin-right:5px; font-weight:bold; border:1px solid #ccc;">非公開</span> ' : '';
                const nameLink = `<strong onclick="openAuthorPage('${c.user_id}')" style="cursor:pointer; text-decoration:underline;">${name}</strong>`;
                let manageBtns = '';
                if (isMine) manageBtns = `<span onclick="startEditComment('${c.id}', \`${c.body.replace(/`/g, '\\`')}\` )" style="cursor:pointer; color:#007bff; font-size:0.8em; margin-left:12px; text-decoration: underline;">編集</span><span onclick="deleteComment('${c.id}')" style="cursor:pointer; color:#dc3545; font-size:0.8em; margin-left:8px; text-decoration: underline;">削除</span>`;
                const replyBtn = `<span onclick="prepareReply('${c.id}', '${name}')" style="cursor:pointer; color:#666; font-size:0.8em; margin-left:12px; text-decoration: underline;">返信</span>`;
                const style = isReply ? 'margin-left: 30px; border-left: 2px solid #ddd; padding-left: 10px; margin-top: 8px;' : 'margin-bottom: 8px;';
                return `<div class="comment-item" style="${style}">${privateMark}${nameLink}: <span>${c.body}</span> ${replyBtn}${manageBtns}</div>`;
            };
            return `<div style="margin-bottom: 15px;">${renderComment(p, false)}${replies.filter(r => String(r.parent_id) === String(p.id)).map(r => renderComment(r, true)).join('')}</div>`;
        }).join('');
    }
    function prepareReply(parentId, targetName) {
        currentReplyId = parentId;
        const input = document.getElementById('comment-input');
        input.placeholder = `${targetName} さんへの返信...`;
        input.focus();
    }
    async function startEditComment(commentId, oldBody) {
        const newBody = prompt("コメントを編集しますか？", oldBody);
        if (newBody === null || newBody.trim() === "" || newBody === oldBody) return;
        const { error } = await api.from('comments').update({ body: newBody.trim() }).eq('id', commentId);
        if (error) alert("編集に失敗しました: " + error.message); else loadComments(currentReadingId);
    }
    async function postComment() {
        const b = document.getElementById('comment-input').value.trim();
        const isPrivate = document.getElementById('comment-is-private').checked;
        if(!b || !currentUser) return;
        
        const safeId = String(currentReadingId); 

        const displayName = (userProfile && userProfile.display_name) ? userProfile.display_name : currentUser.email.split('@')[0];
        
        const { error } = await api.from('comments').insert({ 
            novel_id: safeId, 
            user_id: currentUser.id, 
            user_name: displayName, 
            body: b, 
            is_private: isPrivate, 
            parent_id: currentReplyId 
        });

        if (error) { 
            alert("コメント失敗: " + error.message); 
        } else {
            if (currentOpenedNovel && currentOpenedNovel.author_id !== currentUser.id) {
                await api.from('notifications').insert({ 
                    target_user_id: currentOpenedNovel.author_id, 
                    from_user_name: displayName, 
                    type: currentReplyId ? 'reply' : 'comment', 
                    novel_title: currentOpenedNovel.title, 
                    novel_id: safeId,
                    is_private: isPrivate 
                });
            }
            if (currentReplyId) {
                const { data: parentC } = await api.from('comments').select('user_id').eq('id', currentReplyId).single();
                if (parentC && parentC.user_id !== currentUser.id && parentC.user_id !== currentOpenedNovel.author_id) {
                    await api.from('notifications').insert({ 
                        target_user_id: parentC.user_id, 
                        from_user_name: displayName, 
                        type: 'reply', 
                        novel_title: currentOpenedNovel.title, 
                        novel_id: safeId, 
                        is_private: isPrivate 
                    });
                }
            }
            document.getElementById('comment-input').value = ""; 
            document.getElementById('comment-input').placeholder = "感想を書く..."; 
            document.getElementById('comment-is-private').checked = false; 
            currentReplyId = null; 
            loadComments(safeId);
        }
    }
    
    async function deleteComment(id) {
        if (!confirm("このコメントを削除しますか？")) return;
        const { error } = await api.from('comments').delete().eq('id', id).eq('user_id', currentUser.id);
        if (error) alert("削除に失敗しました。"); else loadComments(currentReadingId);
    }
    async function checkFollowStatus(authorId) {
        const { data } = await api.from('follows').select('*').eq('follower_id', currentUser.id).eq('following_id', authorId).maybeSingle();
        const btn = document.getElementById('follow-btn');
        if (!btn) return;
        if (data) { btn.innerText = "フォロー中"; btn.style.background = "#fcaf17"; btn.style.color = "#fff"; } 
        else { btn.innerText = "フォローする"; btn.style.background = "#fff"; btn.style.color = "#fcaf17"; }
    }
    async function toggleFollow(authorId) {
        if (!currentUser) return alert("ログインが必要です");
        const { data: existing } = await api.from('follows').select('*').eq('follower_id', currentUser.id).eq('following_id', authorId).maybeSingle();
        if (existing) await api.from('follows').delete().eq('id', existing.id);
        else {
            const { error: insertError } = await api.from('follows').insert({ follower_id: currentUser.id, following_id: authorId });
            if (!insertError && authorId !== currentUser.id) await api.from('notifications').insert({ target_user_id: authorId, from_user_name: userProfile?.display_name || "名無しさん", type: 'follow', novel_title: "" });
        }
        checkFollowStatus(authorId);
    }

    async function checkNotifications() {
        if (!currentUser) return;
        
        const { data } = await api.from('notifications')
            .select('*')
            .eq('target_user_id', currentUser.id)
            .eq('is_read', false)
            .order('created_at', { ascending: false });

        const banner = document.getElementById('notification-banner');
        
        if (data && data.length > 0) {
            document.getElementById('notification-list').innerHTML = data.map(n => {
                let message = `<strong>${n.from_user_name}</strong> さんが `;
                
                const titleHtml = (n.novel_id && n.novel_id !== "null")
                    ? `<span class="notification-link" onclick="openReader('${n.novel_id}')">「${n.novel_title}」</span>` 
                    : `「${n.novel_title}」`;

                if (n.type === 'reply') message += `${titleHtml} で返信しました！`;
                else if (n.type === 'comment') message += `${titleHtml} にコメントしました！`;
                else if (n.type === 'like') message += `${titleHtml} にいいねしました！`;
                else if (n.type === 'bookmark') message += `${titleHtml} をブックマークしました！`;
                else if (n.type === 'follow') message += `あなたをフォローしました！`;
                
                return `<div style="margin-bottom: 4px; padding-bottom: 4px; border-bottom: 1px dashed #ffeeba;">・ ${message}</div>`;
            }).join('');
            
            banner.classList.remove('hidden');
        } else {
            banner.classList.add('hidden');
        }
    }
    
    async function clearNotifications() {
        await api.from('notifications').update({ is_read: true }).eq('target_user_id', currentUser.id);
        document.getElementById('notification-banner').classList.add('hidden');
    }
    async function openAuthorPage(authorId) {
        const overlay = document.getElementById('author-page-overlay');
        const worksEl = document.getElementById('author-page-works');
        const nameEl = document.getElementById('author-page-name');
        const bioEl = document.getElementById('author-page-bio');
        const styleEl = document.getElementById('user-custom-style');
        if (!overlay || !worksEl) return;
        const { data: prof } = await api.from('profiles').select('*').eq('id', authorId).maybeSingle();
        if (!prof) return;
        const fullCode = prof.custom_css || "";
        const cssMatch = fullCode.match(/<style>([\s\S]*?)<\/style>/);
        if (styleEl) styleEl.innerHTML = cssMatch ? cssMatch[1] : fullCode;
        bioEl.innerHTML = fullCode.replace(/<style>[\s\S]*?<\/style>/, "") || prof.bio || "";
        nameEl.innerText = prof.display_name;
        worksEl.innerHTML = "作品を読み込み中...";
        overlay.style.display = 'block';
        closeReader();
        const { data: novels } = await api.from('novels').select('*').eq('author_id', authorId).eq('is_private', false).order('created_at', { ascending: false });
        const customArea = document.getElementById('custom-works-area');
        const targetEl = customArea || worksEl;
        targetEl.innerHTML = (novels || []).map(n => {
            const r18Badge = n.is_r18 ? `<span class="r18-badge">R18</span>` : "";
            return `<div class="novel-row"><div class="novel-info"><span class="novel-title" onclick="openReader('${n.id}')" style="cursor:pointer; position:relative; z-index:4000;">${n.title}</span><div style="display: inline-flex; align-items: center; gap: 8px; margin-left: 10px;"><span class="count-badge">${(n.content || "").length.toLocaleString()}文字</span>${r18Badge}</div></div></div>`;
        }).join('') || "公開作品はありません";
        if (customArea && customArea !== worksEl) worksEl.innerHTML = "";
    }
    function closeAuthorPage() {
        document.getElementById('author-page-overlay').style.display = 'none';
        document.getElementById('user-custom-style').innerHTML = "";
    }

    // ==========================================
    // 9. EVENT LISTENERS
    // ==========================================
    document.addEventListener('DOMContentLoaded', async () => {
        init();
        const { data: { session } } = await api.auth.getSession();
        if (session) { currentUser = session.user; await checkNotifications(); }
        document.addEventListener('change', function(e) {
            if (e.target && e.target.id === 'name-convert-check') {
                const area = document.getElementById('default-name-area');
                if (e.target.checked) area.classList.remove('hidden');
                else { area.classList.add('hidden'); document.getElementById('default-name-input').value = ""; }
            }
        });
    });
    window.addEventListener('pageshow', (event) => { if (event.persisted) window.location.reload(); });
    const readerOverlay = document.getElementById('reader-overlay');
    readerOverlay.addEventListener('scroll', function() {
        const stickyEl = document.querySelector('.sticky-close');
        if (!stickyEl || window.innerWidth > 800) return;
        let st = readerOverlay.scrollTop;
        if (st > lastScrollTop && st > 100) stickyEl.classList.add('nav-hidden');
        else stickyEl.classList.remove('nav-hidden');
        lastScrollTop = st;
    }, { passive: true });
</script>
</body>
</html>
